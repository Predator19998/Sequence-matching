#include <sys/resource.h>
#include <sys/time.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath>
#include <tuple>

using namespace std;

class IOoperator{
    public:
    string s1 = ""; //original strings generated by input file.
    string s2 = "";
    
    /*
    Generating the raw strings before alignment.
    */
    void stringGenerator(int argc, char *argv[]){
        vector<string> lines = this->fileReader(argc, argv);
        string current_string = "";
        int len = 0;        //length of a base string.
        int numOfIndices = 0;          // number of lines consist of indices(j or k).
            for(auto line :lines){
                char char_array[line.length() + 1];
                strcpy(char_array, line.c_str());
                if (char_array[0] <= 'Z' && char_array[0] >='A'){
                    if(current_string == ""){
                        current_string = line;
                        len = current_string.length();
                    }
                    else{
                        if(numOfIndices >10 || len >2000 || pow(2,numOfIndices)*len >2000){
                            perror("Invalid Input String s1");
                        }
                        s1 = current_string;
                        current_string = line;
                        len = current_string.length();
                        numOfIndices = 0;
                    }
                }
                else {
                    numOfIndices++;
                    string temp;
                    int loc = stoi(line);
                    temp = current_string.substr(0,loc+1);
                    temp.append(current_string,0,current_string.length());
                    temp.append(current_string,loc+1,current_string.length()-loc-1);
                    current_string = temp;
                      
                }
            }
            if(numOfIndices >10 || len >2000 || pow(2,numOfIndices)*len >2000){
                perror("Invalid Input String s2");
                
            }
            s2 = current_string;
    }

    /*
    void fileWriter(int cost, string strAlign1, string strAlign2, float time, float memory)
    Writing output data to output file. If there is a output file given, use it as output file; 
    otherwise build a "output.txt" as output file.
    <Parameter>
    cost: Cost of the alignment (Integer)
    strAlign1: First string alignment ( Consists of A, C, T, G, _ (gap) characters)    
    strAlign2: Second string alignment ( Consists of A, C, T, G, _ (gap) characters )
    time: Time in Milliseconds (Float)
    memory: Memory in Kilobytes (Float)

    */

    void fileWriter(int cost, string strAlign1, string strAlign2, float time, float memory){
        ofstream outfile;
        outfile.open(this->outFile);
        if(!outfile.is_open()){
            ofstream outfile("output.txt");
        }
        // ofstream outfile(this->outFile);
       
    
            outfile<<cost<<endl;
            outfile<<strAlign1<<endl;
            outfile<<strAlign2<<endl;
            outfile<<time<<endl;
            outfile<<memory<<endl;
            outfile.close();
        
    }

    /*
    For debug use, print s1 and s2 to command line.
    */
    void stringPrinter(){
        cout<<"s1: "<<s1<<endl;
        cout<<"s2: "<<s2<<endl;
    }


    private:

    /*
    Read lines from given input file, store lines into a std::vector<std::string>.
    */
    vector<string> fileReader(int argc, char *argv[]){
        vector<string> output;
        // this->argc = argc;
        
        char *inLines = NULL;
        string inFile = "";
        this->outFile = "output.txt";
        if (argc == 1){
        perror("Input file invalid");
        }
        inFile = argv[1];
        if( argc >= 3 ) {
        this->outFile = argv[2];
        }
        ifstream infile(inFile);
        string line;  
        if(infile.is_open()){
            while(getline(infile, line)){
                output.push_back(line);
            }

            infile.close();
        }
        else perror("Input file invalid");
        return output;
    }
    string outFile = "";    //output filename.
};

extern int errno;

string outs1,outs2;
int cost = 0,cost2;

int miss_arr[4][4] = {0,110,48,94,
                    110,0,118,48,
                    48,118,0,110,
                    94,48,110,0};

// getrusage() is available in linux. Your code will be evaluated in Linux OS.
long getTotalMemory() {
    struct rusage usage;
    int returnCode = getrusage(RUSAGE_SELF, &usage);
    if(returnCode == 0) {
    return usage.ru_maxrss;
} else {
    //It should never occur. Check man getrusage for more info to debug.
    // printf("error %d", errno);
    return -1;
    }
}

int findMin(int a, int b, int c){
    if(a<b && a<c) return a;
    else if(b<c) return b;
    return c;
}

//Lookup table for Mismatch penalty
int findPenmiss(char a, char b) {
    int i,j;
    switch(a) {
        case 'A' : i=0;break;
        case 'C' : i=1;break;
        case 'G' : i=2;break;
        case 'T' : i=3;break;
        default:break;
    }
    switch(b) {
        case 'A' : j=0;break;
        case 'C' : j=1;break;
        case 'G' : j=2;break;
        case 'T' : j=3;break;
        default:break;
    }
    return miss_arr[i][j];
}

string* sequenceAlignment(string x, string y,int pen_gap){
    cost2=0;
    string s1,s2;
    string res[2];

    int i,j;

    int m = x.length();
    int n = y.length();

    int dp[n+m+1][n+m+1];

    for(i=0;i<=(n+m);i++) {
        dp[i][0] = i*pen_gap;
        dp[0][i] = i*pen_gap;
    }

    for(i=1;i<=m;i++) {
        for(j=1;j<=n;j++) {
            if(x[i-1] == y[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = findMin(dp[i-1][j-1] + findPenmiss(x[i-1],y[j-1]), dp[i-1][j] + pen_gap, dp[i][j-1] + pen_gap);
            }
        }
    }

    int l = n+m;

    i=m;j=n;

    int xpos=l;
    int ypos=l;

    char xalign[l+1], yalign[l+1];

    //Finidng the aligned sequence
    while(!(i==0||j==0)){
        if(x[i-1] == y[j-1]) {
            xalign[xpos--] = x[i-1];
            yalign[ypos--] = y[j-1];
            i--;j--;
        }
        else if (dp[i-1][j-1] + findPenmiss(x[i-1],y[j-1]) == dp[i][j]) {
            xalign[xpos--] = x[i-1];
            yalign[ypos--] = y[j-1];
            i--;j--;            
        }
        else if(dp[i-1][j] + pen_gap == dp[i][j]) {
            xalign[xpos--] = x[i-1];
            yalign[ypos--] = '_';
            i--;            
        }
        else if(dp[i][j-1] + pen_gap == dp[i][j]) {
            xalign[xpos--] = '_';
            yalign[ypos--] = y[j-1];
            j--;            
        }
    }
    while (xpos>0) {
        if(i>0) xalign[xpos--] = x[--i];
        else xalign[xpos--] = '_';
    }
    while (ypos>0) {
        if(j>0) yalign[ypos--] = y[--j];
        else yalign[ypos--] = '_';
    }

    int use=1;
    i=1;
    while(yalign[i] == '_' && xalign[i] == '_') {
        use=i+1;
        i++;
    }

    //printf("Minimum penalty = %d\n",dp[m][n]);
    cost2 = dp[m][n]; //The minumum penalty of the sequence alignment
    //cout<<"alignment cost = "<<cost<<endl;
    //printf("Aligned Sequence\n");
    //Storing the aligned sequence
    for(i=use;i<=l;i++){
        //printf("%c",xalign[i]);
        s1 = s1+xalign[i];
    }
    //printf("\n");
    for(i=use;i<=l;i++){
        //printf("%c",yalign[i]);
        s2 = s2+yalign[i];
    }
    //cout<<outs1<<endl<<outs2<<endl;
    res[0] = s1; res[1] = s2;
    return res;
}

int* keepScore(string x,string y,int pen_gap) {
    //cout<<"xlength="<<x.length()<<",ylength="<<y.length()<<endl;
    int score[x.length()+1][y.length()+1];

    for(int i=0; i<x.length()+1;i++) {
        for(int j=0; j<y.length()+1;j++) score[i][j] = 0;
    }
    for(int j=1; j<y.length()+1;j++) score[0][j] = score[0][j-1] + pen_gap;
    for(int i=1; i<x.length()+1;i++) {
        score[1][0] = score[0][0] + pen_gap;
        for(int j=1 ; j<y.length();j++) {
            score[1][j]=findMin(score[0][j-1]+findPenmiss(x[i-1],y[j-1]),score[0][j]+pen_gap,score[1][j-1]+pen_gap);
        }
        for(int j=0 ; j<y.length();j++){
            score[0][j] = score[1][j];
        }
    }
    int *lastLine = (int*)malloc(y.length()*sizeof(int));
    for(int j=0 ; j<y.length();j++) {
        lastLine[j] = score[1][j];
    }
    return lastLine;
}

string * efficientAlignment(string x, string y, int pen_gap){
    string a = "" , b = "";
    string *res = (string*)malloc(2*sizeof(string));
    //cout<<x.length()<<","<<y.length()<<endl;
    if(x.length()==0) {
        for(int i=0;i<y.length();i++) {
            a=a+'_';
            b=b+y[i];
            cost+=pen_gap;
        }
    }
    else if(y.length()==0){
        for(int i=0;i<x.length();i++) {
            a=a+x[i];
            b=b+'_';
            cost+=pen_gap;
        }
    }
    else if(x.length()<=2||y.length()<=2) {
        res = sequenceAlignment(x,y,pen_gap);
        a = res[0];
        b = res[1];
        cost+=cost2;
    }
    else {
        int xlen=x.length();
        int ylen=y.length();
        int xmid=x.length()/2;
        //cout<<"mid="<<xmid<<endl;
        int *scoreL = (int*) malloc (ylen*sizeof(int));
        scoreL=keepScore(x.substr(0,xmid),y,pen_gap);
        string reversedString1 = x.substr(xmid,xlen);
        reverse(reversedString1.begin(),reversedString1.end());
        string reversedString2 = y;
        reverse(reversedString2.begin(),reversedString2.end());
        //cout<<reversedString1<<"\n";
        //cout<<reversedString2<<"\n";
        int *scoreR=(int*) malloc (ylen*sizeof(int));
        scoreR = keepScore(reversedString1,reversedString2,pen_gap);

        // cout<<"ScoreL=";
        // for(int i=0;i<ylen;i++){
        //     cout<<scoreL[i]<<" ";
        // }
        // cout<<endl;
        // cout<<"ScoreR=";
        // for(int j=ylen-1;j>=0;j--){
        //     cout<<scoreR[j]<<" ";
        // }
        // cout<<endl;
        int scoreSum[ylen];
        // cout<<"Scoresum=";
        for(int i=0,j=ylen-1;i<ylen,j>=0;i++,j--) {
            scoreSum[i] = scoreL[i] + scoreR[j];
            // cout<<scoreSum[i]<<" ";
        }
        //cout<<endl;
        int min=0;
        for(int i=1;i<ylen;i++) {
            if (scoreSum[min]>scoreSum[i]) min=i;
        }
        int ymid = min;
        //cout<<scoreSum[min]<<endl;
        //if (localcost<scoreSum[min]) localcost = scoreSum[min];
        a = a + efficientAlignment(x.substr(0,xmid),y.substr(0,ymid),pen_gap)[0] + efficientAlignment(x.substr(xmid,xlen),y.substr(ymid,ylen),pen_gap)[0];
        b = b + efficientAlignment(x.substr(0,xmid),y.substr(0,ymid),pen_gap)[1] + efficientAlignment(x.substr(xmid,xlen),y.substr(ymid,ylen),pen_gap)[1];
    }
    //cout<<a<<endl<<b<<endl;
    res[0] = a;res[1]=b;
    return res;
}

int main(int argc, char *argv[]) {

    IOoperator myio;
    string s1,s2;
    string * res2 = (string*)malloc(2*sizeof(string));
    struct timeval begin, end;
    gettimeofday(&begin, 0);
    //write your solution here
    //Please call getTotalMemory() only after calling your solution function. It calculates max memory used by the program.
    myio.stringGenerator(argc, argv);
    myio.stringPrinter();
    int pen_gap = 30;

    //efficientAlignment(,myio.s2,pen_gap);
    res2 = efficientAlignment("ACACACTGACTACTGACTGGTGACTACTGACTGGACTGACTACTGACTGGTGACTACTGACTGG","TTATTATACGCGACGCGATTATACGCGACGCG",pen_gap);
    double totalmemory = getTotalMemory();
    gettimeofday(&end, 0);
    long seconds = end.tv_sec - begin.tv_sec;
    long microseconds = end.tv_usec - begin.tv_usec;
    double totaltime = seconds*1000 + microseconds*1e-3;
    // printf("\nTotal time = %f\n", totaltime);
    // printf("Total memory = %f\n", totalmemory);
    //myio.fileWriter(cost,outs1,outs2,totaltime,totalmemory);
    cout<<"cost="<<cost/2<<endl;
    cout<<res2[0]<<"\n"<<res2[1];
}