#include <sys/resource.h>
#include <sys/time.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath>
#include <tuple>

using namespace std;

class IOoperator{
    public:
    string s1 = ""; //original strings generated by input file.
    string s2 = "";
    
    /*
    Generating the raw strings before alignment.
    */
    void stringGenerator(int argc, char *argv[]){
        vector<string> lines = this->fileReader(argc, argv);
        string current_string = "";
        int len = 0;        //length of a base string.
        int numOfIndices = 0;          // number of lines consist of indices(j or k).
            for(auto line :lines){
                char char_array[line.length() + 1];
                strcpy(char_array, line.c_str());
                if (char_array[0] <= 'Z' && char_array[0] >='A'){
                    if(current_string == ""){
                        current_string = line;
                        len = current_string.length();
                    }
                    else{
                        if(numOfIndices >10 || len >2000 || pow(2,numOfIndices)*len >2000){
                            perror("Invalid Input String s1");
                        }
                        s1 = current_string;
                        current_string = line;
                        len = current_string.length();
                        numOfIndices = 0;
                    }
                }
                else {
                    numOfIndices++;
                    string temp;
                    int loc = stoi(line);
                    temp = current_string.substr(0,loc+1);
                    temp.append(current_string,0,current_string.length());
                    temp.append(current_string,loc+1,current_string.length()-loc-1);
                    current_string = temp;
                      
                }
            }
            if(numOfIndices >10 || len >2000 || pow(2,numOfIndices)*len >2000){
                perror("Invalid Input String s2");
                
            }
            s2 = current_string;
    }

    /*
    void fileWriter(int cost, string strAlign1, string strAlign2, float time, float memory)
    Writing output data to output file. If there is a output file given, use it as output file; 
    otherwise build a "output.txt" as output file.
    <Parameter>
    cost: Cost of the alignment (Integer)
    strAlign1: First string alignment ( Consists of A, C, T, G, _ (gap) characters)    
    strAlign2: Second string alignment ( Consists of A, C, T, G, _ (gap) characters )
    time: Time in Milliseconds (Float)
    memory: Memory in Kilobytes (Float)

    */

    void fileWriter(int cost, string strAlign1, string strAlign2, float time, float memory){
        ofstream outfile;
        outfile.open(this->outFile);
        if(!outfile.is_open()){
            ofstream outfile("output.txt");
        }
        // ofstream outfile(this->outFile);
       
    
            outfile<<cost<<endl;
            outfile<<strAlign1<<endl;
            outfile<<strAlign2<<endl;
            outfile<<time<<endl;
            outfile<<memory<<endl;
            outfile.close();
        
    }

    /*
    For debug use, print s1 and s2 to command line.
    */
    void stringPrinter(){
        cout<<"s1: "<<s1<<endl;
        cout<<"s2: "<<s2<<endl;
    }


    private:

    /*
    Read lines from given input file, store lines into a std::vector<std::string>.
    */
    vector<string> fileReader(int argc, char *argv[]){
        vector<string> output;
        // this->argc = argc;
        
        char *inLines = NULL;
        string inFile = "";
        this->outFile = "output.txt";
        if (argc == 1){
        perror("Input file invalid");
        }
        inFile = argv[1];
        if( argc >= 3 ) {
        this->outFile = argv[2];
        }
        ifstream infile(inFile);
        string line;  
        if(infile.is_open()){
            while(getline(infile, line)){
                output.push_back(line);
            }

            infile.close();
        }
        else perror("Input file invalid");
        return output;
    }
    string outFile = "";    //output filename.
};

extern int errno;

string outs1,outs2;
int cost = 0,cost2;

int miss_arr[4][4] = {0,110,48,94,
                    110,0,118,48,
                    48,118,0,110,
                    94,48,110,0};

// getrusage() is available in linux. Your code will be evaluated in Linux OS.
long getTotalMemory() {
    struct rusage usage;
    int returnCode = getrusage(RUSAGE_SELF, &usage);
    if(returnCode == 0) {
    return usage.ru_maxrss;
} else {
    //It should never occur. Check man getrusage for more info to debug.
    // printf("error %d", errno);
    return -1;
    }
}

int findMin(int a, int b, int c){
    if(a<b && a<c) return a;
    else if(b<c) return b;
    return c;
}

//Lookup table for Mismatch penalty
int findPenmiss(char a, char b) {
    int i,j;
    switch(a) {
        case 'A' : i=0;break;
        case 'C' : i=1;break;
        case 'G' : i=2;break;
        case 'T' : i=3;break;
        default:break;
    }
    switch(b) {
        case 'A' : j=0;break;
        case 'C' : j=1;break;
        case 'G' : j=2;break;
        case 'T' : j=3;break;
        default:break;
    }
    return miss_arr[i][j];
}

void sequenceAlignment(string x, string y,int pen_gap){
    int len1 = x.length();
    int len2 = y.length();
    int a = 0;

    int dp[2][len2+1];

    memset(dp,0,sizeof dp);
    for(int i=0;i<=len1;i++){
        dp[0][i] = i*pen_gap;
    }

    //takes only 2 indices for the x array for memory efficiency i.e only 0 and 1
    for(int i=1;i<=len1;i++){
        a=1-a;
        for(int j=0;j<=len2;j++){
            if(i==0) dp[a][j] = j*pen_gap;

            else if (j==0) dp[a][j] = i*pen_gap;

            else if(x[i-1]==y[j-1]) dp[a][j] = dp[1-a][j-1];

            else dp[a][j] = findMin(dp[1-a][j-1] + findPenmiss(x[i-1],y[j-1]),dp[a][j-1] + pen_gap,dp[1-a][j] + pen_gap);
        }
    }

    //final resultant cost of the sequence alignment
    cout<<dp[a][len1]<<endl;

    //todo reconstrct the sequence either in the above loop or a new loop
}

int main(int argc, char *argv[]) {

    IOoperator myio;
    string s1,s2;
    string * res2 = (string*)malloc(2*sizeof(string));
    struct timeval begin, end;
    gettimeofday(&begin, 0);
    //write your solution here
    //Please call getTotalMemory() only after calling your solution function. It calculates max memory used by the program.
    myio.stringGenerator(argc, argv);
    //myio.stringPrinter();
    int pen_gap = 30;

    sequenceAlignment(myio.s1,myio.s2,pen_gap);
    //res2 = efficientAlignment("AGGGCT","AGGCA",pen_gap);
    double totalmemory = getTotalMemory();
    gettimeofday(&end, 0);
    long seconds = end.tv_sec - begin.tv_sec;
    long microseconds = end.tv_usec - begin.tv_usec;
    double totaltime = seconds*1000 + microseconds*1e-3;
    // printf("\nTotal time = %f\n", totaltime);
    // printf("Total memory = %f\n", totalmemory);
    //myio.fileWriter(cost,outs1,outs2,totaltime,totalmemory);
    //cout<<"cost="<<cost/2<<endl;
    cout<<res2[0]<<"\n"<<res2[1];
}